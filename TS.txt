Написать микросервисное приложение «Банк» с использованием Spring Boot, интеграций Spring Cloud и паттернов микросервисной архитектуры.
Одним из сервисов приложения будет фронт (Front UI), который обеспечивает взаимодействие пользователя (клиента банка) с микросервисами. Рекомендуем написать этот сервис самостоятельно с нуля, чтобы получить полноценную практику работы с приложением. Но если у вас недостаточно времени, мы подготовили архив с шаблоном фронта.
В архиве Maven-проект, сгенерированный с помощью start.spring.io, который можно открыть в среде разработки, например, в IntelliJ IDEA.
В проекте уже реализованы:
HTML-страница фронта src/main/resources/templates/main.html;
контроллер MainController, принимающий запросы и возвращающий main.html;
DTO для передачи данных между MainController и main.html.
В комментариях к методам MainController описано, что это за метод, для чего он нужен и как вам его нужно реализовать.
В шаблоне проекта используется сервис AccountStub — удалите его. Он нужен для ознакомления с проектом, чтобы вы могли запустить фронт в среде разработки и изучить, как он работает.
Для запуска проекта:
Распакуйте архив.
Откройте его как Maven-проект в среде разработки, например, в IntelliJ IDEA.
Запустите main-класс MyBankFrontAppApplication.
Откройте в браузере http://localhost:8080.
Скриншоты фронта:
Главная страница:
Скриншот главной страницы.
Ошибка при снятии денег со счёта, если недостаточно средств:
Скриншот ошибки.
Успешное пополнение счёта:
Скриншот страницы.
Успешный перевод средств на счёт другого клиента:
Скриншот страницы.
Требования к приложению
Микросервисы приложения написаны на Spring Boot с использованием интеграций Spring Cloud.
Код приложения хранится в публичном Git-репозитории на GitHub.
Микросервисы приложения собираются с помощью Maven или Gradle.
Есть возможность собирать сразу все микросервисы одной командой (например, с помощью parent POM и использования мультимодульных проектов).
Код приложения написан на Java 21.
Фронт приложения может использовать Spring Web MVC или Spring WebFlux.
Приложение может использовать Spring Data JDBC, Spring Data R2DBC или Spring Data JPA и Hibernate ORM под капотом для доступа к данным в базе данных.
Базы данных для микросервисов приложения должны быть персистентными (например, PostgreSQL). Можно обойтись одной базой данных, но разграничить микросервисы на уровне схем, чтобы реализовать паттерн Database per Service.
В качестве Gateway API использовать самописный сервис со Spring Cloud Gateway.
В качестве Service Discovery можно использовать Consul, Eureka, ZooKeeper или самописный сервис, реализующий паттерн Service Discovery. Микросервисы должны интегрироваться с ним через соответствующий проект Spring Cloud.
Фронт должен выполнять запросы в микросервисы через Gateway API.
Микросервисы должны выполнять запросы в другие микросервисы напрямую и регистрироваться в Service Discovery.
В качестве Externalized/Distributed Config можно использовать Consul, ZooKeeper или самописный сервис, реализующий паттерн Externalized/Distributed Config, с использованием проекта Spring Cloud Config.
Микросервисы должны получать общие настройки из Externalized/Distributed Config.
В качестве сервера авторизации OAuth 2.0 можно использовать Keycloak, любой другой, который можно установить локально, или самописный сервер авторизации OAuth 2.0 с использованием проекта Spring Security OAuth.
В микросервисах авторизация должна осуществляться на сервере OAuth 2.0 по Client Credentials Flow, чтобы можно было получать Access Token (JWT) для выполнения запросов в другие микросервисы (межсервисная авторизация).
На фронте авторизация должна осуществляться на сервере OAuth 2.0 по Authorization Code Flow, чтобы можно было получить Access Token (JWT) для выполнения запросов из фронта в другие микросервисы (пользовательская авторизация).
Фронт и микросервисы приложения можно собрать из исходников и запустить локально.
Фронт и микросервисы приложения должны быть упакованы в Executable JAR и запускаться в Tomcat, Jetty или Netty.
Приложение покрыто тестами (юнит, интеграционными, контрактными) с использованием JUnit 5, TestContext Framework, Spring Boot Test, кеширования контекстов и Spring Cloud Contract.
Фронт и микросервисы должны быть написаны и протестированы с использованием паттернов микросервисной архитектуры приложения.
Executable JAR фронта и микросервисов должны быть упакованы в Docker-контейнеры с открытым веб-портом для доступа из браузера или межсервисного взаимодействия, чтобы реализовать паттерн Single Service per Host.
Запускать фронт и микросервисы можно все вместе с помощью Docker Compose или по одному вручную с помощью команд Docker.
Функциональность
Микросервисное приложение «Банк» — это приложение с веб-интерфейсом (фронт), которое позволяет пользователю (клиенту банка):
редактировать данные своего аккаунта (фамилию и имя, дату рождения);
класть виртуальные деньги на счёт своего аккаунта и снимать их;
переводить виртуальные деньги на счёт другого аккаунта.
Приложение состоит из следующих частей:
фронт (Front UI);
микросервис аккаунтов (Accounts);
микросервис обналичивания денег (Cash);
микросервис перевода денег на счёт другого аккаунта (Transfer);
микросервис уведомлений (Notifications).
Фронт (Front UI)
Фронт (Front UI) — это веб-приложение с клиентским HTML-интерфейсом. Представляет собой одну HTML-страницу, которая доступна только после успешной аутентификации/авторизации пользователя.
Аутентификация/авторизация пользователя осуществляется на сервере авторизации OAuth 2.0 по Authorization Code Flow, в результате которого фронт получает JWT-токен с данными, ролями и правами вошедшего пользователя для выполнения запросов в микросервисы.
В JWT-токене должна содержаться следующая информация:
логин вошедшего пользователя;
привилегии для доступа в сервисы Accounts, Cash и Transfer.
Страница содержит:
блок данных аккаунта пользователя;
блок внесения и снятия виртуальных денег;
блок перевода денег на счёт другого аккаунта.
Блок данных аккаунта пользователя
Состоит из:
поля фамилии и имени (с возможностью редактирования);
даты рождения (с возможностью редактирования);
текущей суммы на счёте (без возможности редактирования);
кнопки «Сохранить изменений».
Должна быть предусмотрена валидация: все поля заполнены, возраст старше 18 лет. При сохранении невалидных данных должна появляться ошибка.
Блок внесения и снятия виртуальных денег
Состоит из:
поля ввода суммы снятия (обязательно для заполнения);
кнопок «Положить» и «Снять» (если сумма, которую нужно снять, больше суммы на счёте, то появляется ошибка).
Блок перевода денег на счёт другого аккаунта
Состоит из:
поля выбора аккаунта пользователя (обязательно для выбора);
поля ввода суммы перевода (обязательно для заполнения);
кнопки «Перевести» (если сумма перевода больше суммы на счёте отправителя, то появляется ошибка).
Можно предусмотреть разлогинивание пользователя из фронта и сервера авторизации.
Микросервис аккаунтов (Accounts)
Микросервис аккаунтов хранит информацию о зарегистрированных аккаунтах и их счетах.
В нём хранятся:
логин пользователя (аккаунт связывается с вошедшим пользователем по этому логину и логину из JWT);
фамилия и имя;
дата рождения;
количество денег на счету.
Микросервис Accounts авторизуется на OAuth 2.0 по Client Credentials Flow для осуществления запросов в другие микросервисы. В JWT-токене должны быть привилегии для доступа в сервис Notifications.
Взаимодействие с фронтом и другими микросервисами:
Фронт выполняет REST-запросы (в формате JSON) из блока данных аккаунта в сервис Accounts:
при получении данных своего аккаунта;
при редактировании данных своего аккаунта;
при получении логина и фамилии и имени других аккаунтов для выполнения переводов.
Accounts выполняет REST-запросы (в формате JSON) в Notifications.
Микросервис обналичивания денег (Cash)
Микросервис обналичивания денег осуществляет пополнение счёта или снятие денег со счёта.
Он авторизуется на OAuth 2.0 по Client Credentials Flow для осуществления запросов в другие микросервисы. В JWT-токене должны быть привилегии для доступа в сервисы Accounts и Notifications.
Взаимодействие с фронтом и другими микросервисами:
Фронт выполняет REST-запросы (в формате JSON) из блока внесения и снятия виртуальных денег в сервис Cash.
Cash выполняет REST-запросы (в формате JSON) в Accounts для внесения и снятия виртуальных денег.
Cash выполняет REST-запросы (в формате JSON) в Notifications.
Сервис перевода денег между счетами (Transfer)
Сервис перевода денег между счетами осуществляет перевод денег между счетами разных пользователей.
Он авторизуется на OAuth 2.0 по Client Credentials Flow для осуществления запросов в другие микросервисы. В JWT-токене должны быть привилегии для доступа в сервисы Accounts и Notifications.
Взаимодействие с фронтом и другими микросервисами:
Фронт выполняет REST-запросы (в формате JSON):
из блока внесения и снятия виртуальных денег в сервис Accounts для получения логинов и фамилий и имени других аккаунтов пользователей;
из блока внесения и снятия виртуальных денег в сервис Transfer.
Transfer выполняет REST-запросы (в формате JSON) в Accounts для снятия виртуальных денег со счёта текущего пользователя и внесения на счёт другого пользователя.
Transfer выполняет REST-запросы (в формате JSON) в Notifications.
Сервис уведомлений (Notifications)
Сервис уведомлений отправляет уведомления (на ваш выбор: пишет в лог, на почту, выдаёт Alert и т. д.) о выполненном действии: переводе денег, пополнении счёта, снятии денег со счёта и т. д.
Итоговая схема взаимодействия сервисов выглядит так:
Схема взаимодействия сервисов, описанная в тексте.
Пользователь на фронте должен аутентифицироваться/авторизовываться на сервере авторизации по Authorization Code Flow, чтобы выполнять запросы в другие микросервисы.
Фронт выполняет запросы в микросервисы через Gateway API, поэтому на Gateway API должен быть реализован проброс пользовательского JWT-токена в микросервисы.
Микросервисы должны аутентифицироваться/авторизовываться на сервере авторизации по Client Credentials Flow, чтобы выполнять запросы в другие микросервисы. У одного микросервиса может не быть доступа к выполнению запросов в другой микросервис (например, микросервис Cash не может выполнять запросы в Transfer).
У пользователя есть доступ к информации только о сумме на своём счёте.
Как работать над заданием
Изучить описание задания (веб-страницы, функциональность, типы микросервисов, их взаимодействие).
Спроектировать и реализовать приложение в соответствии с требованиями проекта.
Стараться использовать микрокоммиты при разработке приложения.
После финального коммита сделать пуш на GitHub.
Шаги по разработке приложения
Для проекта создать новый репозиторий в своём профиле на GitHub (например, с названием my-bank-app). Профиль должен быть публичным, чтобы ревьюер мог с ним работать.
Клонировать репозиторий к себе в локальный Git-репозиторий. Вся работа над проектом ведётся в отдельной ветке в соответствии с парадигмой GitFlow.
Спроектировать фронт и микросервисы в соответствии с требованиями и функциональностью проекта и паттернами микросервисных приложений.
На фронте и в каждом микросервисе спроектировать слои согласно паттернам разработки корпоративных приложений (view только для Front UI, controller/REST-controller, service, model, DAO).
Спроектировать классы/подмодули в каждом слое согласно принципам и паттернам разработки SOLID, YAGNI и т. д.
Создать микросервисы с нуля с использованием инструментов Spring Boot (например, start.spring.io). Фронт можно создать с нуля или использовать готовый шаблон.
Объединить фронт и все микросервисы под одним родительским проектом (мультипроектом, в котором фронт и каждый микросервис — это подпроект).
Создать проект для этого мультипроекта в среде разработки (например, в IntelliJ Idea).
Инициализировать проект Git.
Выбрать систему сборки (Maven/Gradle).
Установить одну СУБД с разграничением схем (для каждого микросервиса своя схема) или по одной СУБД для каждого микросервиса, которому она нужна (можно в контейнере).
Создать Spring Boot-приложение со Spring Cloud Gateway для реализации Gateway API.
Установить и настроить Consul или Zookeper для реализации Service Discovery и Externalized/Distributed Configs, если используются в проекте.
Создать Spring Boot-приложение с Eureka Server и настроить его для реализации Service Discovery, если используется в проекте.
Создать Spring Boot-приложение с реализацией Service Discovery и Externalized/Distributed Configs, если используются самописные решения.
Установить и настроить OAuth 2.0 Server (например, Keycloak), если он используется в проекте для авторизации.
Создать Spring Boot-приложение со Spring Security OAuth Server и настроить его, если используется самописный сервер авторизации OAuth 2.0.
Добавить зависимости на Spring Boot, зависимости и стартеры Spring WebMVC, Spring WebFlux, Spring Data JDBC, JPA, R2DBC, Spring Cloud проекты и т. д.
Написать классы слоя модели, DAO, сервисов, контроллеров, view (шаблонизатор Thymeleaf), REST-клиентов в каждом из микросервисов.
Написать модульные, интеграционные и контрактные тесты на микросервисы и взаимодействие между ними (Spring Cloud Contract).
Написать сборку Executable JAR для фронта и каждого из микросервисов.
Написать Dockerfile для развёртывания и запуска каждого приложения в Docker. Можно написать Docker Compose для развёртывания и запуска всего мультипроекта.
Написать README.md (как собирать и запускать приложение в среде разработки, локально и в Docker).
В процессе разработки приложения делать микрокоммиты в Git, дописывать файлы описания сборки Maven/Gradle, накатки схемы БД и т. д.
После финального коммита сделать пуш на GitHub.
Что проверит ревьюер
Правильность описания мультипроекта и подпроектов для фронта и каждого микросервиса в pom.xml или build.gradle.
Структуру, схему взаимодействия фронта и микросервисов, права доступа, роли при взаимодействии в соответствии с паттернами разработки микросервисных приложений: Circuit Breaker, Service Discovery, Gateway API, RPI, Transactional Outbox, Access Token, UI Composition, Contract Testing, Externalized/Distributed Configs и т. д.
Структуру фронта и каждого микросервиса согласно слоям приложения, правильное расположение слоёв и взаимодействие между ними.
Структуру и взаимодействие классов согласно принципам и паттернам разработки корпоративных приложений.
Наименование классов, методов, полей и других элементов в соответствии с их назначением.
Правильность использования Spring Boot для разработки веб-приложения и RESTful-сервисов.
Правильность реализации авторизации по Authorization Code Flow и Client Credentials Flow на сервисе авторизации OAuth 2.0 для взаимодействия фронта с микросервисами и микросервисов между собой.
Правильность проектирования структур БД для хранения данных.
Покрытие модульными, интеграционными и контрактными тестами в соответствии с заданием.
Правильность написания Dockerfile для развёртывания и запуска фронта и микросервисов в Docker-контейнере, а также файла Docker Compose.
Подробность и понятность описания проекта в README.md, форматирование.
Использование микрокоммитов при разработке приложения.
Правильное использование rebase/merge-слияний в истории проекта.
Зелёные прогоны тестов.
Что не нужно делать (будет в следующих спринтах)
Настраивать репликации микросервисов и Load Balancer.
Использовать шины данных, JMS, Kafka для межсервисного взаимодействия и поставки логов.
Агрегировать, хранить и анализировать логи (ELK-стек).
Настраивать Health Check, мониторинг микросервисов, аудит.
Настраивать распределённые трассировки.
Развёртывать микросервисы в Kubernetes.
Использовать Jenkins CI/CD или аналоги.
Как сдавать проект

Сдать работу

Вперёд
